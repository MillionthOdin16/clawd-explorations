#!/usr/bin/env python3
"""
Error Logger - Log failures with context (v1.0.0)

Usage:
    from scripts.error_logger import log_error, log_tool_failure
    
    try:
        result = some_tool_call()
        if not result:
            log_tool_failure("tool_name", "No result returned")
    except Exception as e:
        log_error("tool_name", str(e), context={"additional": "info"})
"""

import json
import os
import sys
from datetime import datetime
from typing import Any, Dict, Optional


class ErrorLogger:
    """Log errors with context for debugging."""
    
    def __init__(self, log_dir: str = None):
        self.log_dir = log_dir or "/home/opc/clawd/.logs"
        os.makedirs(self.log_dir, exist_ok=True)
    
    def log(
        self,
        error_type: str,
        message: str,
        context: Dict = None,
        severity: str = "error"
    ) -> str:
        """
        Log an error with context.
        
        Args:
            error_type: Type of error (tool_name, category)
            message: Error message
            context: Additional context (session, command, etc.)
            severity: error, warning, info
            
        Returns:
            Log file path
        """
        timestamp = datetime.utcnow().isoformat()
        
        log_entry = {
            "timestamp": timestamp,
            "type": error_type,
            "severity": severity,
            "message": message,
            "context": context or {},
        }
        
        # Write to daily log file
        date_str = datetime.utcnow().strftime("%Y-%m-%d")
        log_file = os.path.join(self.log_dir, f"errors-{date_str}.jsonl")
        
        with open(log_file, "a") as f:
            f.write(json.dumps(log_entry) + "\n")
        
        return log_file
    
    def log_tool_failure(
        self,
        tool_name: str,
        error_message: str,
        command: str = None,
        session_id: str = None,
        retry_count: int = 0
    ) -> str:
        """
        Log a tool failure with full context.
        
        Args:
            tool_name: Name of the tool that failed
            error_message: The error message
            command: The command that was attempted
            session_id: Current session ID
            retry_count: How many times retried
            
        Returns:
            Log file path
        """
        context = {
            "tool": tool_name,
            "command": command,
            "session_id": session_id,
            "retry_count": retry_count,
        }
        
        return self.log(
            error_type=f"tool_failure:{tool_name}",
            message=error_message,
            context=context,
            severity="error"
        )
    
    def log_research_session(
        self,
        topic: str,
        findings: str,
        sources: list = None
    ) -> str:
        """
        Log research session and create memory file.
        
        Args:
            topic: Research topic
            findings: Key findings
            sources: List of source URLs
            
        Returns:
            Memory file path
        """
        timestamp = datetime.utcnow().isoformat()
        
        memory_content = f"""# {topic}

**Researched:** {timestamp}

## Summary

{findings}

## Sources

"""
        if sources:
            for source in sources:
                memory_content += f"- {source}\n"
        else:
            memory_content += "- No sources recorded\n"
        
        memory_content += "\n---\n*Auto-generated by error-logger during research session*\n"
        
        # Create memory file
        safe_name = topic.lower().replace(" ", "-").replace("/", "-")[:50]
        memory_file = f"/home/opc/clawd/memory/RESEARCH-{safe_name}.md"
        
        with open(memory_file, "w") as f:
            f.write(memory_content)
        
        # Also log the research session
        self.log(
            error_type="research_session",
            message=f"Research completed: {topic}",
            context={
                "topic": topic,
                "memory_file": memory_file,
                "sources": sources or [],
            },
            severity="info"
        )
        
        return memory_file
    
    def get_recent_errors(
        self,
        error_type: str = None,
        limit: int = 10
    ) -> list:
        """
        Get recent errors from logs.
        
        Args:
            error_type: Filter by error type
            limit: Maximum number of errors to return
            
        Returns:
            List of error entries
        """
        date_str = datetime.utcnow().strftime("%Y-%m-%d")
        log_file = os.path.join(self.log_dir, f"errors-{date_str}.jsonl")
        
        if not os.path.exists(log_file):
            return []
        
        errors = []
        with open(log_file, "r") as f:
            for line in f:
                entry = json.loads(line.strip())
                if error_type is None or entry.get("type", "").startswith(error_type):
                    errors.append(entry)
        
        return errors[-limit:]
    
    def get_error_stats(self) -> dict:
        """Get error statistics for today."""
        date_str = datetime.utcnow().strftime("%Y-%m-%d")
        log_file = os.path.join(self.log_dir, f"errors-{date_str}.jsonl")
        
        if not os.path.exists(log_file):
            return {"total": 0, "by_type": {}}
        
        stats = {"total": 0, "by_type": {}, "by_severity": {}}
        
        with open(log_file, "r") as f:
            for line in f:
                entry = json.loads(line.strip())
                stats["total"] += 1
                
                error_type = entry.get("type", "unknown")
                severity = entry.get("severity", "unknown")
                
                stats["by_type"][error_type] = stats["by_type"].get(error_type, 0) + 1
                stats["by_severity"][severity] = stats["by_severity"].get(severity, 0) + 1
        
        return stats


# Global logger instance
logger = ErrorLogger()


def log_error(
    error_type: str,
    message: str,
    context: Dict = None,
    severity: str = "error"
) -> str:
    """Convenience function for logging errors."""
    return logger.log(error_type, message, context, severity)


def log_tool_failure(
    tool_name: str,
    error_message: str,
    command: str = None,
    session_id: str = None,
    retry_count: int = 0
) -> str:
    """Convenience function for logging tool failures."""
    return logger.log_tool_failure(
        tool_name, error_message, command, session_id, retry_count
    )


def log_research_session(
    topic: str,
    findings: str,
    sources: list = None
) -> str:
    """Convenience function for logging research sessions."""
    return logger.log_research_session(topic, findings, sources)


def main():
    """CLI interface for error logger."""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Error logging utility",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
EXAMPLES:
    # Log an error
    python scripts/error-logger.py log --type browser --message "Chrome not available"
    
    # Log a tool failure
    python scripts/error-logger.py tool-failure --tool coolify --message "API error"
    
    # Log research session
    python scripts/error-logger.py research --topic "AI Consciousness" --findings "..."
    
    # View recent errors
    python scripts/error-logger.py errors --limit 5
    
    # View error stats
    python scripts/error-logger.py stats
"""
    )
    
    subparsers = parser.add_subparsers(dest="command", help="Commands")
    
    # Log command
    parser_log = subparsers.add_parser("log", help="Log an error")
    parser_log.add_argument("--type", required=True, help="Error type")
    parser_log.add_argument("--message", required=True, help="Error message")
    parser_log.add_argument("--severity", default="error", choices=["error", "warning", "info"])
    
    # Tool failure command
    parser_tool = subparsers.add_parser("tool-failure", help="Log a tool failure")
    parser_tool.add_argument("--tool", required=True, help="Tool name")
    parser_tool.add_argument("--message", required=True, help="Error message")
    parser_tool.add_argument("--command", help="Command that failed")
    
    # Research command
    parser_research = subparsers.add_parser("research", help="Log research session")
    parser_research.add_argument("--topic", required=True, help="Research topic")
    parser_research.add_argument("--findings", required=True, help="Key findings")
    parser_research.add_argument("--sources", help="Comma-separated sources")
    
    # Errors command
    parser_errors = subparsers.add_parser("errors", help="View recent errors")
    parser_errors.add_argument("--limit", type=int, default=10, help="Number of errors")
    parser_errors.add_argument("--type", help="Filter by error type")
    
    # Stats command
    subparsers.add_parser("stats", help="View error statistics")
    
    args = parser.parse_args()
    
    if args.command == "log":
        path = log_error(args.type, args.message, severity=args.severity)
        print(f"✅ Logged: {path}")
    
    elif args.command == "tool-failure":
        sources = args.sources.split(",") if args.sources else None
        path = log_tool_failure(args.tool, args.message, args.command)
        print(f"✅ Logged tool failure: {path}")
    
    elif args.command == "research":
        sources = args.sources.split(",") if args.sources else None
        path = log_research_session(args.topic, args.findings, sources)
        print(f"✅ Created memory file: {path}")
    
    elif args.command == "errors":
        errors = logger.get_recent_errors(args.type, args.limit)
        for error in errors:
            print(f"{error['timestamp']} [{error['severity']}] {error['type']}: {error['message']}")
    
    elif args.command == "stats":
        stats = logger.get_error_stats()
        print(f"Total errors today: {stats['total']}")
        print(f"\nBy type:")
        for error_type, count in stats["by_type"].items():
            print(f"  {error_type}: {count}")
        print(f"\nBy severity:")
        for severity, count in stats["by_severity"].items():
            print(f"  {severity}: {count}")
    
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
