#!/usr/bin/env python3
"""
Ralph Spec-Executor Unit Tests
Tests for the key functions in spec-executor.py
"""

import unittest
import sys
import os
import tempfile
import shutil
import re


def extract_function_from_do(do_field, filename):
    """Extract function information from **Do** field."""
    if not do_field:
        return None, []
    
    func_pattern = r'with\s+(\w+)\s*\(([^)]*)\)\s*function'
    match = re.search(func_pattern, do_field)
    
    if match:
        func_name = match.group(1)
        params = match.group(2)
        param_list = [p.strip() for p in params.split(',') if p.strip()]
        return func_name, param_list
    
    return None, []


def generate_python_content(filename, do_field, description):
    """Generate Python file content based on task description."""
    func_name, params = extract_function_from_do(do_field, filename)
    
    if func_name:
        if params:
            sig = ', '.join(params)
        else:
            sig = ''
        
        func_bodies = {
            'add': '    return a + b',
            'subtract': '    return a - b',
            'multiply': '    return a * b',
            'divide': '    if b == 0: raise ValueError("Cannot divide by zero")\n    return a / b',
            'greet': '    return f"Hello, {name}!"',
            'echo': '    return " ".join(args)',
            'hello': '    return "Hello, World!"',
        }
        
        body = func_bodies.get(func_name, '    pass')
        
        if body == '    pass' and params:
            param_names = [p.split()[1] if ' ' in p else p for p in params]
            body = f'    # TODO: implement\n    return ({", ".join(param_names)})'
        
        content = f'''#!/usr/bin/env python3
"""Auto-generated by Ralph spec-executor."""

def {func_name}({sig}):
{body}


if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        try:
            result = {func_name}(*sys.argv[1:])
            print(result)
        except TypeError:
            print(f"Usage: python {filename} [args...]")
    else:
        print(f"{func_name}() = {{{func_name}()}}")
'''
    else:
        base_name = os.path.splitext(filename)[0]
        content = f'''#!/usr/bin/env python3
"""Auto-generated by Ralph spec-executor."""

import sys

def main():
    """Main function."""
    pass

if __name__ == "__main__":
    main()
'''
    
    return content


def extract_file_names(files_field):
    """Extract file names from **Files** field."""
    if not files_field:
        return []
    files = re.split(r'[\n,]', files_field)
    return [f.strip() for f in files if f.strip()]


def parse_task_sections(task_content):
    """Parse Do, Files, Done when, Verify, Commit from task."""
    sections = {
        'do': None,
        'files': None,
        'done_when': None,
        'verify': None,
        'commit': None,
        'description': None
    }
    
    desc_match = re.match(r'^- \[.+\] (\d+\.\d+) (.+?)(?:\n  \*\*|\s*$)', task_content)
    if desc_match:
        sections['description'] = f"{desc_match.group(1)} {desc_match.group(2)}"
    
    for section in ['do', 'files', 'done_when', 'verify', 'commit']:
        pattern = r'  \*\*' + section.capitalize() + r'\*\*:\s*(.+?)(?=\n  \*\*|\n*$)'
        match = re.search(pattern, task_content, re.DOTALL)
        if match:
            value = match.group(1).strip()
            sections[section] = value
    
    return sections


def read_file(path):
    """Read file content safely."""
    try:
        with open(path, 'r') as f:
            return f.read()
    except FileNotFoundError:
        return None


def create_file_from_task(filename, spec_path, do_field, description):
    """Create a file based on task description."""
    filepath = os.path.join(spec_path, filename)
    
    if filename.endswith('.py'):
        content = generate_python_content(filename, do_field, description)
    elif filename.endswith('.sh'):
        content = f'''#!/bin/bash
# Auto-generated by Ralph spec-executor
# TODO: Implement: {do_field[:50]}
echo "Hello"
'''
    elif filename.endswith('.md'):
        content = f'''# {filename}

Auto-generated by Ralph spec-executor.

## Description
{description}

## Implementation
{do_field}
'''
    else:
        content = f'''# {filename}
Auto-generated by Ralph spec-executor.
'''
    
    with open(filepath, 'w') as f:
        f.write(content)
    
    return filepath


class TestExtractFunctionFromDo(unittest.TestCase):
    """Test function extraction from **Do** field."""
    
    def test_add_function(self):
        func_name, params = extract_function_from_do(
            "Create calculator.py with add(a, b) function",
            "calculator.py"
        )
        self.assertEqual(func_name, "add")
        self.assertEqual(params, ["a", "b"])
    
    def test_multiply_function(self):
        func_name, params = extract_function_from_do(
            "Create multiplier.py with multiply(a, b) function",
            "multiplier.py"
        )
        self.assertEqual(func_name, "multiply")
        self.assertEqual(params, ["a", "b"])
    
    def test_greet_function(self):
        func_name, params = extract_function_from_do(
            "Create greeter.py with greet(name) function",
            "greeter.py"
        )
        self.assertEqual(func_name, "greet")
        self.assertEqual(params, ["name"])
    
    def test_no_function(self):
        func_name, params = extract_function_from_do(
            "Create config.py for settings",
            "config.py"
        )
        self.assertIsNone(func_name)
        self.assertEqual(params, [])


class TestGeneratePythonContent(unittest.TestCase):
    """Test Python code generation."""
    
    def test_add_function_generation(self):
        content = generate_python_content(
            "calculator.py",
            "Create calculator.py with add(a, b) function",
            "Create calculator"
        )
        self.assertIn("def add(a, b):", content)
        self.assertIn("return a + b", content)
    
    def test_multiply_function_generation(self):
        content = generate_python_content(
            "multiplier.py",
            "Create multiplier.py with multiply(a, b) function",
            "Create multiplier"
        )
        self.assertIn("def multiply(a, b):", content)
        self.assertIn("return a * b", content)
    
    def test_greet_function_generation(self):
        content = generate_python_content(
            "greeter.py",
            "Create greeter.py with greet(name) function",
            "Create greeter"
        )
        self.assertIn("def greet(name):", content)
        self.assertIn('f"Hello, {name}!"', content)
    
    def test_generic_python(self):
        content = generate_python_content(
            "utils.py",
            "Create utility functions",
            "Create utilities"
        )
        self.assertIn("#!/usr/bin/env python3", content)
        self.assertIn("def main():", content)


class TestExtractFileNames(unittest.TestCase):
    """Test file name extraction."""
    
    def test_single_file(self):
        files = extract_file_names("calculator.py")
        self.assertEqual(files, ["calculator.py"])
    
    def test_multiple_files_newline(self):
        files = extract_file_names("calculator.py\nmultiplier.py")
        self.assertEqual(files, ["calculator.py", "multiplier.py"])
    
    def test_multiple_files_comma(self):
        files = extract_file_names("calculator.py, multiplier.py")
        self.assertEqual(files, ["calculator.py", "multiplier.py"])
    
    def test_empty(self):
        files = extract_file_names(None)
        self.assertEqual(files, [])


class TestParseTaskSections(unittest.TestCase):
    """Test task parsing."""
    
    def test_parse_complete_task(self):
        task_content = """- [ ] 1.1 Create calculator.py
  **Do**: Create calculator.py with add(a, b) function
  **Files**: calculator.py
  **Done when**: python -c "from calculator import add; assert add(2,3) == 5"
  **Verify**: python -c "from calculator import add; assert add(2,3) == 5" && echo "PASS"
  **Commit**: feat: add calculator.py with add function"""
        
        task = parse_task_sections(task_content)
        
        self.assertEqual(task['description'], "1.1 Create calculator.py")
        self.assertIn("add(a, b)", task['do'])
        self.assertEqual(task['files'], "calculator.py")
        self.assertIn("add(2,3)", task['verify'])
        self.assertEqual(task['commit'], "feat: add calculator.py with add function")


class TestIntegration(unittest.TestCase):
    """Integration tests."""
    
    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()
        self.spec_path = os.path.join(self.temp_dir, 'test-spec')
        os.makedirs(self.spec_path)
    
    def tearDown(self):
        shutil.rmtree(self.temp_dir)
    
    def test_create_python_file_with_function(self):
        filepath = create_file_from_task(
            "calculator.py",
            self.spec_path,
            "Create calculator.py with add(a, b) function",
            "Test calculator"
        )
        
        self.assertTrue(os.path.exists(filepath))
        
        content = read_file(filepath)
        self.assertIn("def add(a, b):", content)
        self.assertIn("return a + b", content)
    
    def test_create_markdown_file(self):
        filepath = create_file_from_task(
            "README.md",
            self.spec_path,
            "Create README for the project",
            "Test project"
        )
        
        self.assertTrue(os.path.exists(filepath))
        
        content = read_file(filepath)
        self.assertIn("# README.md", content)
        self.assertIn("Test project", content)


def run_tests():
    """Run all tests and return results."""
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()
    
    suite.addTests(loader.loadTestsFromTestCase(TestExtractFunctionFromDo))
    suite.addTests(loader.loadTestsFromTestCase(TestGeneratePythonContent))
    suite.addTests(loader.loadTestsFromTestCase(TestExtractFileNames))
    suite.addTests(loader.loadTestsFromTestCase(TestParseTaskSections))
    suite.addTests(loader.loadTestsFromTestCase(TestIntegration))
    
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    return result.wasSuccessful()


if __name__ == '__main__':
    success = run_tests()
    print(f"\n{'='*60}")
    if success:
        print("ALL TESTS PASSED ✓")
    else:
        print("SOME TESTS FAILED ✗")
    print(f"{'='*60}")
    sys.exit(0 if success else 1)
